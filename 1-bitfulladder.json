{
	"inputtext" : ["<NAME>", "<INPUT_BIT1>", "<INPUT_BIT2>", "<INPUT_CARRY_BIT>", "<CARRY_BIT>", "<SUM_BIT>"],
	"moduleName" : "1-bit Full Adder",
        "moduleCode" : "-- ALU of N-bits with sum, subtract and logical operations\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_signed.all;\nentity <NAME> is\n-- The input numbers should be introduce in 2's Complement form\nPort ( <OPERAND_A> : in  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n<OPERAND_B> : in  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n<SELECT> : in  STD_LOGIC_VECTOR (2 downto 0);\n<RESULT> : out  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n<CARRY_FLAG> : out  STD_LOGIC;\n<OVERFLOW_FLAG> : out  STD_LOGIC;\n<ZERO_FLAG> : out  STD_LOGIC;\n<NEGATIVE_FLAG> : out  STD_LOGIC);\nend <NAME>;\narchitecture Behavioral of <NAME> is\nsignal result_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0);\nsignal a_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0); --The operands should be introduced in Complement-2 form\nsignal b_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0);\nsignal sum_overflow: std_logic;\nsignal subtract1_overflow: std_logic;\nsignal subtract2_overflow: std_logic;\nbegin\n--A bit is added to both operands to be able to save the result of the operations with the carry included\n--Because the numbers are in Complement-2, this bit can be 0 or 1\na_aux <= '0'&<OPERAND_A> when <OPERAND_A>(<NUMBER_OF_BITS>)=0 else\n'1';\nb_aux <= '0'&<OPERAND_B> when <OPERAND_B>(<NUMBER_OF_BITS>)=0 else\n'1';\n--Then, looking at the select input, the corresponding operation is performed\nresult_aux<= a_aux when <SELECT>=\"000\" else\na_aux + b_aux when <SELECT>=\"001\" else\na_aux - b_aux when <SELECT>=\"010\" else\nb_aux - a_aux when <SELECT>=\"011\" else\nnot(a_aux) when <SELECT>=\"100\" else\na_aux and b_aux when <SELECT>=\"101\" else\na_aux or b_aux when <SELECT>=\"110\" else\na_aux xor b_aux when <SELECT>=\"111\" else\n\"00000\";\n\n<ZERO_FLAG><='1' when result_aux=\"00000\" else				--Active high when the result is zero\n'0';\n\n<NEGATIVE_FLAG><='1' when result_aux(<NUMBER_OF_BITS>+1)='1' else		--Active high when the result is negative\n'0';\n<CARRY_FLAG> <='1' when result_aux(<NUMBER_OF_BITS>+1)='1' else		--Active high when there is carry (MSB of result is '1')\n'0';\n-- In order to get the overflow, the calculations are made for the 3 operations that could\n-- cause it and then the correct value is selected with a multiplexor\n--A+B\nsum_overflow <= '1' when(a_aux(<NUMBER_OF_BITS>)='0' and b_aux(3)='0'\nand result_aux(<NUMBER_OF_BITS>)='1') 			--When A and B are positive and the result is negative\nelse\n'1' when(a_aux(<NUMBER_OF_BITS>)='1' and b_aux(<NUMBER_OF_BITS>)='1'\nand result_aux(<NUMBER_OF_BITS>)='0')			--When A and B are negative and the result is positive\nelse '0';\n--A-B\nsubtract1_overflow <='1' when (a_aux(<NUMBER_OF_BITS>)='0' and b_aux(<NUMBER_OF_BITS>)='1'\nand result_aux(<NUMBER_OF_BITS>)='1') 		--When A is positive, B negative and result is negative\nelse\n'1' when (a_aux(<NUMBER_OF_BITS>)='1' and b_aux(<NUMBER_OF_BITS>)='0'\nand result_aux(<NUMBER_OF_BITS>)='0')		--When A is negative, B positive and result is positive\nelse '0';\n--B-A\nsubtract2_overflow <= '1' when (b_aux(<NUMBER_OF_BITS>)='0' and a_aux(<NUMBER_OF_BITS>)='1'\nand result_aux(<NUMBER_OF_BITS>)='1') 		--When B is positive, A negative and result is negative\nelse\n'1' when (b_aux(<NUMBER_OF_BITS>)='1' and a_aux(<NUMBER_OF_BITS>)='0'\nand result_aux(<NUMBER_OF_BITS>)='0')		--When B is negative, A positive and result is positive\nelse '0';\n<OVERFLOW_FLAG> <= ovf_suma when <SELECT>=\"001\" else\novf_resta1 when <SELECT>=\"010\" else\novf_resta2 when <SELECT>=\"011\" else\n'0';\n\n<RESULT> <= result_aux(<NUMBER_OF_BITS> downto 0);\nend Behavioral;"
}
