{
	  "inputtext" : ["<NAME>", "<NUMBER_OF_BITS>", "<RESET>", "<CLOCK>", "<RXD>", "<OUTPUT>", "<FINISH_FLAG>"],
	"selects" : 
	[
		{ "name" : "<EDGE_TYPE>", "options" : [ "rising_edge", "falling_edge"] },
		{ "name" : "<PARITY>", "options" : [ "0", "1"] }
	],
	  "moduleName" : "Generic UART Receiver",
	  "moduleCode" : "--- N-bit UART Receiver with configurable Baud Rate \n--- Made by Carmen Rodr√≠guez Villaverde\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_Unsigned.ALL;\nuse IEEE.math_real.all;\n\nentity <NAME> is\n    Generic (Bauds: integer:= 115200);\n    Port ( <CLOCK> : in  STD_LOGIC;\n           <RESET> : in  STD_LOGIC;\n           <RXD> : in  STD_LOGIC;\n           <FINISH_FLAG> : out  STD_LOGIC;\n           <OUTPUT> : out  STD_LOGIC_VECTOR(<NUMBER_OF_BITS> downto 0)\n); \nend <NAME>;\n\narchitecture Behavioral of <NAME> is\n\n    ---- Control Unit Signals ----\n    type estado_type is (WaitStart, BitStart, WaitBit, SaveBit, LoadOutput, Final);\n    signal current_state, following_state: estado_type;\n    signal Rst, EN, LoadSR, IncCont, LoadOut, HalfPulse: STD_LOGIC;\n\n    --- Operational Unit Signals ----\n    signal OutputSR: std_logic_vector(<NUMBER_OF_BITS> downto 0);\n    signal counter: std_logic_vector(4 downto 0);\n    signal Q,Qt, ContN, RX_DF: std_logic;\n    Constant pulses: integer:=50000000/Bauds;\n    Constant half: integer:= pulses/2;\n    Constant bits: integer:= integer(ceil(log2(real(pulses))));\n    \n    Signal Count: std_logic_vector(bits-1 downto 0);\n    Signal parity_bit: std_logic; \n\nbegin\n------------- Control Unit --------------------\n    process(<CLOCK>, <RESET>)\n        begin\n            if <RESET>='1' then\n                current_state <= WaitStart;\n            elsif <EDGE_TYPE>(<CLOCK>) then\n                current_state <= following_state;\n            end if;\n        end process;\n    --States evolution\n    process (Cont7,RX_DF,HalfPulse,current_state)\n        begin\n            case current_state is\n                when WaitStart =>\n                    if RX_DF = '1' then                --Rising edge detection --> start reception\n                        following_state <= BitStart;\n                    else\n                        following_state <= WaitStart;\n                    end if;\n                when BitStart =>\n                    if HalfPulse = '1' then\n                        following_state <= WaitBit;\n                    else\n                        following_state <= BitStart;\n                    end if;\n                when WaitBit =>                     --When on the half of the pulse, load bit and increment counter\n                    if HalfPulse = '1' then\n                        following_state <= SaveBit;\n                    else\n                        following_state <= WaitBit;\n                    end if;        \n                when SaveBit =>\n                    if ContN = '1' then              --If all bits received, load output\n                        following_state <= LoadOutput;\n                    else\n                        following_state <= WaitBit;\n                    end if;    \n                when LoadOutput =>\n                        following_state <= Final;\n                when others =>\n                        following_state <= WaitStart;\n            end case;\n        end process;\n    \n    --Salidas    \n    Rst <= '1' when current_state = WaitStart else '0';\n    EN <= '0' when current_state = WaitStart else '1';\n    LoadSR <= '1' when current_state = SaveBit else '0';\n    IncCont <= '1' when current_state = SaveBit else '0';        --Enables the counter of the number of bits loaded\n    LoadOut <= '1' when current_state = LoadOutput else '0';\n    <FINISH_FLAG> <= '1' when current_state = Final else '0';\n\n------------- Operational Unit -------------\n    -- Counter for the number of bits received\n    process(<CLOCK>,<RESET>)\n    begin\n        if <RESET> = '1' then\n            counter <= (others =>'0');\n        elsif <EDGE_TYPE>(<CLOCK>) then\n            if IncCont = '1' then\n                counter <= counter+1;\n            end if;\n        end if;\n    end process;\n    ContN <= '1' when counter=<NUMBER_OF_BITS> else '0';\n\n    -- Shift register to save the bits being received\n    process(<CLOCK>,<RESET>)\n    begin\n        if <RESET> = '1' then\n            OutputSR <= (others =>'0');\n            parity_bit <= '<PARITY>';        -- For even parity, initialize at '0'. For odd, initialize at '1'\n        elsif <EDGE_TYPE>(<CLOCK>) then        \n            if LoadSR = '1' then\n                OutputSR <= <RXD>&OutputSR(<NUMBER_OF_BITS> downto 1);\n                \n                if <RXD>='1' then\n                    parity_bit <= not(parity_bit); --changes parity bit according to value\n                end if;\n                \n            end if;\n        end if;\n    end process;\n\n    -- Output Register to load the bits received into the output signal\n    process(<CLOCK>,<RESET>)\n    begin\n        if <RESET> = '1' then\n            <OUTPUT> <= (others =>'0');\n        elsif <EDGE_TYPE>(<CLOCK>) then\n            if LoadOut = '1' then\n                if <RXD>=parity_bit then --checks if parity is correct\n                    <OUTPUT> <= OutputSR;\n                else \n                    <OUTPUT> <= (others=>'0');\n                end if;\n            end if;\n        end if;\n    end process;\n\n    -- Edge detector for the intput signal\n    process(<CLOCK>,<RESET>)\n    begin\n        if <RESET> = '1' then\n            Q <= '0';\n            Qt <= '0';\n        elsif <EDGE_TYPE>(<CLOCK>) then\n            Q <= <RXD>;\n            Qt <= Q;\n        end if;\n    end process;\n    RX_DF <= (Qt) and not(Q); \n\n    --- Cycles counter\n    process(<CLOCK>,<RESET>)\n    begin\n        if <RESET> = '1' then\n            Count <= (others =>'0');\n        elsif <EDGE_TYPE>(<CLOCK>) then\n            if Rst = '1' then\n                Count <= (others =>'0');\n            elsif En = '1' then\n                if Count < (pulses-1) then\n                    Count <= Count +1;\n                else \n                    Count <= (others =>'0');\n                end if;\n            end if;\n        end if;\n    end process;\n    HalfPulse <= '1' when Count=half else '0';\nend Behavioral;"
}
