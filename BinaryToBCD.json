{
	"inputtext" : ["<NAME>", "<INPUT>", "<OUTPUT>"],
	"moduleName" : "Binary to BCD Converter",
	"moduleCode" : "--Binary to BCD converter of 8-bits (Double dabble algorithm)\n--Made by Carmen Rodríguez Villaverde\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse ieee.std_logic_unsigned.all;\n\nentity <NAME> is\n    Port ( <INPUT> : in  STD_LOGIC_VECTOR (7 downto 0);\n           <OUTPUT> : out  STD_LOGIC_VECTOR (9 downto 0));\nend <NAME>;\n\narchitecture Behavioral of <NAME> is\n    signal p:std_logic_vector(9 downto 0);\n\nbegin\n    process(<INPUT>)\n        variable z:std_logic_vector (17 downto 0);\n    begin\n        for i in 0 to 17 loop\n            z(i):='0';                 --Initialize the variable    \n        end loop; \n        z(10 downto 3):= <INPUT>;       --The first 3 shifts right can be done\n                                    --outside of the loops because z\n                                    -- won't be greater than 4 until after\n        for i in 0 to 4 loop\n            if z(11 downto 8)>4 then                          --Units:\n                z(11 downto 8):=z(11 downto 8) + \"0011\";  --When greater than 4, we add 3 because when it is shifted by one (doubled)\n            end if;                          --we get a 6, which will make the number carry (10+6=16) onto the next 4 bits\n            if z(15 downto 12)>4 then  \n                z(15 downto 12):=z(15 downto 12) + \"0011\";--Same process with the tenths\n            end if;\n            z(17 downto 1):=z(16 downto 0);            --Shift again (3 shifts made before +5 in this loop=8=nºbits)\n        end loop;\n         \n        p<= z(17 downto 8);                       --Save the bits needed\n    end process; \n<OUTPUT> <= p;\nend Behavioral;"
}
