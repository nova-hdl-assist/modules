{
	"inputtext" : ["<NAME>", "<OPERAND_A>", "<OPERAND_B>", "<SELECT>", "<RESULT>", "<CARRY_FLAG>", "<OVERFLOW_FLAG>", "<ZERO_FLAG>" , "<NEGATIVE_FLAG>", "<NUMBER_OF_BITS>"],
	"moduleName" : "Basic ALU",
        "moduleCode" : "-- ALU of N-bits with sum, subtract and logical operations\n\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_signed.all;\n\nentity <NAME> is\n    -- The input numbers should be introduce in 2's Complement form\n    Port ( <OPERAND_A> : in  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n           <OPERAND_B> : in  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n           <SELECT> : in  STD_LOGIC_VECTOR (2 downto 0); \n           <RESULT> : out  STD_LOGIC_VECTOR (<NUMBER_OF_BITS> downto 0);\n           <CARRY_FLAG> : out  STD_LOGIC;\n           <OVERFLOW_FLAG> : out  STD_LOGIC;\n           <ZERO_FLAG> : out  STD_LOGIC;\n           <NEGATIVE_FLAG> : out  STD_LOGIC);\nend <NAME>;\n\narchitecture Behavioral of <NAME> is\n    signal result_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0);\n    signal a_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0); \n    signal b_aux: std_logic_vector((<NUMBER_OF_BITS>+1) downto 0);\n    signal sum_overflow: std_logic;\n    signal subtract1_overflow: std_logic;\n    signal subtract2_overflow: std_logic;\nbegin\n--A bit is added to both operands to be able to save the result of the operations with the carry included\n--Because the numbers are in Complement-2, this bit can be 0 or 1\n\na_aux <= '0'&<OPERAND_A> when <OPERAND_A>(<NUMBER_OF_BITS>)=0 else   \n         '1';\nb_aux <= '0'&<OPERAND_B> when <OPERAND_B>(<NUMBER_OF_BITS>)=0 else\n         '1';\n\n--Then, looking at the select input, the corresponding operation is performed\nresult_aux<= a_aux when <SELECT>=\"000\" else\n             a_aux + b_aux when <SELECT>=\"001\" else\n             a_aux - b_aux when <SELECT>=\"010\" else\n             b_aux - a_aux when <SELECT>=\"011\" else\n             not(a_aux) when <SELECT>=\"100\" else\n             a_aux and b_aux when <SELECT>=\"101\" else\n             a_aux or b_aux when <SELECT>=\"110\" else\n             a_aux xor b_aux when <SELECT>=\"111\" else\n             \"00000\";\n--Active high when the result is zero            \n<ZERO_FLAG><='1' when result_aux=\"00000\" else\n     '0';\n--Active high when the result is negative     \n<NEGATIVE_FLAG><='1' when result_aux(<NUMBER_OF_BITS>+1)='1' else\n     '0';\n--Active high when there is carry (MSB of result is '1') \n<CARRY_FLAG> <='1' when result_aux(<NUMBER_OF_BITS>+1)='1' else\n     '0';\n\n-- In order to get the overflow, the calculations are made for the 3 operations that could \n-- cause it and then the correct value is selected with a multiplexor\n\n--A+B\nsum_overflow <= '1' when(a_aux(<NUMBER_OF_BITS>)='0' and b_aux(3)='0'     \n                and result_aux(<NUMBER_OF_BITS>)='1')             --When A and B are positive and the result is negative\n                else\n                '1' when(a_aux(<NUMBER_OF_BITS>)='1' and b_aux(<NUMBER_OF_BITS>)='1' \n                and result_aux(<NUMBER_OF_BITS>)='0')            --When A and B are negative and the result is positive\n                else '0';\n\n--A-B                 \nsubtract1_overflow <='1' when (a_aux(<NUMBER_OF_BITS>)='0' and b_aux(<NUMBER_OF_BITS>)='1' \n                    and result_aux(<NUMBER_OF_BITS>)='1')         --When A is positive, B negative and result is negative\n                    else\n                    '1' when (a_aux(<NUMBER_OF_BITS>)='1' and b_aux(<NUMBER_OF_BITS>)='0' \n                    and result_aux(<NUMBER_OF_BITS>)='0')        --When A is negative, B positive and result is positive\n                    else '0';\n\n--B-A                  \nsubtract2_overflow <= '1' when (b_aux(<NUMBER_OF_BITS>)='0' and a_aux(<NUMBER_OF_BITS>)='1' \n                    and result_aux(<NUMBER_OF_BITS>)='1')         --When B is positive, A negative and result is negative\n                    else \n                    '1' when (b_aux(<NUMBER_OF_BITS>)='1' and a_aux(<NUMBER_OF_BITS>)='0'\n                    and result_aux(<NUMBER_OF_BITS>)='0')        --When B is negative, A positive and result is positive\n                    else '0';\n\n<OVERFLOW_FLAG> <= ovf_suma when <SELECT>=\"001\" else\n                    ovf_resta1 when <SELECT>=\"010\" else\n                    ovf_resta2 when <SELECT>=\"011\" else\n                    '0';\n      \n<RESULT> <= result_aux(<NUMBER_OF_BITS> downto 0);\nend Behavioral;"
}
